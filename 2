class Vec2 {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}

	add(v2) {
		return new Vec2(this.x + v2.x, this.y + v2.y);
	}

	substract(v2) {
		return this.add(v2.scale(-1));
	}

	scale(s) {
		return new Vec2(this.x * s, this.x * s);
	}

	static distance_sq(v1, v2) {
		return (v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2;
	}

	static distance(v1, v2) {
		return distance_sq(v1, v2) ** .5;
	}
}

const STANDARD_SIZE = 20;

class Dot {
	constructor(position, radius) {
		this.position = position;
		this.radius = radius;
	}

	static standard_size_dot(position) {
		console.log("dot", position);
		return new Dot(position, STANDARD_SIZE);
	}

	draw(ctx) {
		ctx.fillStyle = "black";

		ctx.beginPath();
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		ctx.fill();
	}
}

const STICK_SCALE = 0.5;
const MAX_FABRIK_ITERATIONS = 100;
const FABRIK_TOLERANCE = 1e-8;

class Rope {
	constructor() {
		this.dots = [];
	}

	add_dot(dot) {
		this.dots.push(dot);
	}

	get_dot(position) {
		let possible_dot = this.dots
			.map(dot => ({
				dot: dot,
				distance: Vec2.distance_sq(dot.position, position)
			}))
			.find(({dot, distance}) => distance <= dot.radius ** 2)

		if(possible_dot !== undefined) return possible_dot.dot;
		return null;
	}

	fabrik(end) {
		let d = Array.from(pair_elements(this.dots))
					.map((pp, pn) => Vec2.distance(pp.substract(pn)));
		let b = {...this.dots[0]};

		let n_iter = 0;
		while(n_iter++ < MAX_FABRIK_ITERATIONS && Vec2.distance(this.dots.at(-1), end)) {
			this._forward(end);
			this._backward(b);
		}
	}

	_forward(end) {
		for(let i = this.dots.length - 2; i >= 0
	}

	draw(ctx) {
		this.dots.forEach(dot => dot.draw(ctx));
		for(const {first, second} of pair_elements(this.dots))
			Rope.draw_stick(ctx, first, second);
	}

	static draw_stick(ctx, dot1, dot2) {
		let start = dot1.position;
		let end = dot2.position;
		let width = Math.min(dot1.radius, dot2.radius) * STICK_SCALE;

		ctx.lineWidth = width;
		ctx.beginPath();
		ctx.moveTo(start.x, start.y);
		ctx.lineTo(end.x, end.y);
		ctx.stroke();
	}
}
